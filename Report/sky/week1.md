## week1总结   --2019.6.23 
 > 自7.18返校至今完成的主要有LinuxC第六、第七两章,myshell和myls两个小项目，再加数据结构的树部分。     

 1.通过学习LinuxC第六章学习了一下基本系统调用主要是对文件进行的操作。最重要的是了解了对文件权限的控制的实现:    

  比如假设一串数字100、010、001,1代表该位上有权限,0表示没有,124位置上分别表示读写可执行，那么011就表示可读可写不可执行，要检测他的权限时只要通过它与124做&运算就可以得知是否具有该权限。  
  通过宏定义+switch case 结构可以很好控制权限，这点在myls的参数中就有应用，比如说-la这样的组合参数。  

  3.不管对于myshell还是myls都是先对输入的命令进行解析，解析命令就是对字符串的一些切割拼接处理，注意后面加\0等等问题，解析完成命令后在调用相应的函数进行相应的操作。  

  4.在写ls时的核心问题就是-R的实现了，如果采用递归去遍历所有目录下的所有文件，那么目录嵌套层数太多，递归越深时就会发生栈溢出问题，这就好比bfs的题目用dfs去做也会爆栈。爆栈的原因在于每一次进行下次递归时，都会为下次递归所用的函数开辟新的空间，而本次递归占用的资源又得不到是释放，默认情况下栈区大小是8M,这样递归下去就会导致栈溢出。解决办法主要有两种：  
  (1)尾递归，尾递归意思就是说在函数结束时调用下一个函数，这样就一直是开辟了一个函数所需要的空间，代码体现如下：  

**尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。


function f(x){
  return g(x);
}
上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。

以下两种情况，都不属于尾调用。


// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}
上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。

尾调用不一定出现在函数尾部，只要是最后一步操作即可。


function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。**
但是-R递归好像没办法改写成尾递归。  

(2)链表，这种方法是：改用堆区，也就是malloc申请空间，依照这个方法成功完成-R。  

5.写shell时并没遇到太多复杂问题，一些小bug修修改改。  

中间安装了一个readline库，主要利用库中的readline.h和history.h实现自动补全和追溯历史命令功能，但是readline在处理输入时有些小问题，当删除最后一个字符时会连同前面提示符号一并删除，该问题可以通过readline("$")这样解决，这样提示符就不会被删掉了。

还有一个问题是strcmp段错误,通过查阅资料发现，strcmp源码中未对传入地址合法性检测，体现如下:  
~~~
STRCMP (const char *p1, const char *p2)   
{  

  const unsigned char *s1 = (const unsigned char *) p1; 

  const unsigned char *s2 = (const unsigned char *) p2; 

  unsigned char c1, c2; 

  do 

    {
      c1 = (unsigned char) *s1++;
      c2 = (unsigned char) *s2++;
      if (c1 == '\0')
        return c1 - c2;
    }
  while (c1 == c2);
  return c1 - c2; 

}
~~~
所以要求我们对传入的地址负责，自己进行合法性检测。