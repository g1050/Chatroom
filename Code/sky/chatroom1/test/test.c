1.线程池伪代码
void init()
{
    /****一些初始化******/
    malloc申请头指针
    初始化锁mutex初始化cond;
    pool->maxsize = ;
    pool->task = NULL;//任务队列初始化为空
    ...等初始化操作

    /*******循环创建线程******/
    for()循环创建一定数量的线程{
        每个线程创建时的线程函数是任务接口函数routine    
    }
}

void *routine()
{
    /* 死循环保持所有线程执行完任务后继续阻塞 */
    while(1){
        lock加锁
        
        /* 判断：如果任务队列不为空，不用阻塞直接执行 */
        /* 用while代替if防止虚假唤醒 */
        while(任务数量==0 && 销毁标志不为真){
            基于条件变量cond阻塞;    
        }
   

        从任务队列取出任务(此时持有锁);
        任务队列做相应变化(出队，数量--);
        
        解锁
        执行任务，执行完后return之后仍然回到while(1)里


    }
}

void add_task(要执行的函数指针，函数参数)
{
    构造并初始化一个任务队列的　任务小节点;

    lock加锁;
    将任务加入任务队列(类似单链表尾插法);
    解锁；

    唤醒一个线程去执行相应任务;
}

void destory()
{
    销毁标志置为真值;

    唤醒所有线程;

    for(i < max)循环销毁所有线程
        join阻塞主线程结束线程池中的线程

    free释放init中申请的头指针

    while(cur != NULL)遍历任务队列
        销毁任务队列

    销毁锁，销毁条件变量
}

